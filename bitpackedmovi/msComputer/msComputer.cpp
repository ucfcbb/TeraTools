#include "matchingStatistics/msIndex.h"
#include "util/fasta.h"
#include "util/util.h"

static constexpr size_t DEFAULT_BUFFER_SIZE = 64ULL * 1024ULL * 1024ULL; // 64MB

void printUsage() {
    std::cout << 
        "msComputer computes matching statistics of a pattern.\n"
        "It requires as input the ms index generated by msIndexBuilder.\n"
        "\n"
        "Usage: msComputer <arguments>\n"
        "Options:\n"
        "  Input:\n"
        "    -i          FILE                       REQUIRED       file name of input (ends with '" << ms_index_extension << "'), an index generated by msIndexBuilder.\n"
        "    -q          FILE                       REQUIRED       file name of query file.\n"
        "  Output:\n"
        "    -o          FILE                       optional       base name of output file for matching statistics (writes to FILE.[len|pos]), otherwise QUERY.[len|pos] is used.\n"
        "  Behavior:\n"
        "    -m          [phi,psi,dual]             optional       matching statistics mode. one of 'phi', 'psi', or 'dual'. dual is default.\n"
        "    -p          INT                        optional       Limit the program to (nonnegative) INT threads. By default uses maximum available. Maximum on this hardware is " << omp_get_max_threads() << "\n"
        "    -v          [quiet,time,verb]          optional       Verbosity, verb for most verbose output, time for timer info, and quiet for no output. time is default.\n"
        "    -h, --help                             optional       Print this help message.\n"
        ;
}

struct options{
    std::string indexFile, patternFile, outputFile = "", mode = "dual";
    unsigned numThreads = omp_get_max_threads();
    verbosity v = TIME;
}o;

void processOptions(const int argc, const char* argv[]) {
    std::vector<bool> used(argc);
    used[0] = true;

    if (argc == 1 || getArgument(argc, argv, used, "-h", false, false) != "" || getArgument(argc, argv, used, "--help", false, false) != "") {
        printUsage();
        exit(0);
    }

    o.indexFile = getArgument(argc, argv, used, "-i", true, true);
    o.patternFile = getArgument(argc, argv, used, "-q", true, true);
    std::string s = getArgument(argc, argv, used, "-o", false, true);
    if (s != "") {
        o.outputFile = s;
    } else {
        o.outputFile = o.patternFile;
    }
    s = getArgument(argc, argv, used, "-m", false, true);
    if (s != "" && s != "phi" && s != "psi" && s != "dual") {
        std::cout << "Invalid value passed to -m '" << s << "'\n";
        exit(1);
    }
    else if (s != "") {
        o.mode = s;
    }
    s = getArgument(argc, argv, used, "-p", false, true);
    if (s != "")
        o.numThreads = std::stoul(s); 
    s = getArgument(argc, argv, used, "-v", false, true);
    if (s == "quiet")
        o.v = QUIET;
    else if (s == "time" || s == "")  
        o.v = TIME;
    else if (s == "verb")
        o.v = VERB;
    for (int i = 0; i < argc; ++i) {
        if (!used[i]) {
            std::cout << "Argument " << i << ", '" << argv[i] << "' not recognized or used as an argument for another option. It might have been passed more than once (invalid).\n";
            exit(1);
        }
	}
    testInFile(o.indexFile);
    testInFile(o.patternFile);
}

int main(const int argc, const char*argv[]) {
	processOptions(argc, argv);

    #ifdef STATS
    if (o.numThreads > 1) {
        std::cerr << "Stats are not supported with multiple threads. Please run with -p 1." << std::endl;
        exit(1);
    }
    #endif

    omp_set_num_threads(o.numThreads);

    if (o.v >= TIME) { Timer.start("msComputer"); }
    if (o.v >= TIME) { Timer.start("Program Initialization"); }
	if (o.v >= TIME) { Timer.start("Loading index " + o.indexFile); }
	std::ifstream in(o.indexFile);
	MSIndex msIndex;
	msIndex.load(in);
	in.close();
	if (o.v >= TIME) { Timer.stop(); } //Loading " + o.indexFile

    Timer.start("Opening files for read (" + o.patternFile + ") and write (" + o.outputFile + ".[len|pos])");
    FILE *fp;
    kseq_t *seq = open_fasta(o.patternFile, &fp);
    
    // For maximum performance, use system buffer size
    std::string outputFile_len = o.outputFile + ".len";
    std::string outputFile_pos = o.outputFile + ".pos";
    FILE* out_len = fopen(outputFile_len.c_str(), "w");
    FILE* out_pos = fopen(outputFile_pos.c_str(), "w");
    int fd_len = fileno(out_len);
    int fd_pos = fileno(out_pos);

    long long buffer_size_len = fpathconf(fd_len, _PC_REC_XFER_ALIGN);
    long long buffer_size_pos = fpathconf(fd_pos, _PC_REC_XFER_ALIGN);

    if (buffer_size_len <= 0) {
        buffer_size_len = DEFAULT_BUFFER_SIZE;
    }
    if (buffer_size_pos <= 0) {
        buffer_size_pos = DEFAULT_BUFFER_SIZE;
    }
    setvbuf(out_len, nullptr, _IOFBF, buffer_size_len);
    setvbuf(out_pos, nullptr, _IOFBF, buffer_size_pos);
    Timer.stop(); //Opening files for read (" + o.patternFile + " and write (" + o.outputFile + ")
    Timer.stop(); //Program Initialization

    #ifdef STATS
    msIndex.reset_ms_stats();
    #endif

    auto total_ms_time = 0.0;
    auto total_write_time = 0.0;
    auto total_seq_len = 0;
    auto ms_step = [&](const SeqInfo& seq_info) {
        #pragma omp atomic
        total_seq_len += seq_info.seq_len;
        thread_local static std::pair<std::vector<uint64_t>, std::vector<uint64_t>> ms_result;
        auto start_time = std::chrono::high_resolution_clock::now();
        ms_result.first.clear();
        ms_result.second.clear();
        if (o.mode == "phi") {
            ms_result = msIndex.ms_phi(seq_info.seq_content, seq_info.seq_len);
        } else if (o.mode == "psi") {
            ms_result = msIndex.ms_psi(seq_info.seq_content, seq_info.seq_len);
        } else if (o.mode == "dual") {
            ms_result = msIndex.ms_dual(seq_info.seq_content, seq_info.seq_len);
        } else {
            std::cerr << "Invalid mode: " << o.mode << std::endl;
            exit(1);
        }
        auto end_time = std::chrono::high_resolution_clock::now();
        #pragma omp atomic
        total_ms_time += std::chrono::duration<double>(end_time - start_time).count();

        start_time = std::chrono::high_resolution_clock::now();
        #pragma omp critical(write_ms_result)
        {
            fprintf(out_len, ">%s\n", seq_info.seq_name);
            fprintf(out_pos, ">%s\n", seq_info.seq_name);
            for (uint64_t i = 0; i < ms_result.first.size(); ++i) {
                fprintf(out_len, "%lu ", ms_result.first[i]);
                fprintf(out_pos, "%lu ", ms_result.second[i]);
            }
            fprintf(out_len, "\n");
            fprintf(out_pos, "\n");
        }
        end_time = std::chrono::high_resolution_clock::now();
        #pragma omp atomic
        total_write_time += std::chrono::duration<double>(end_time - start_time).count();
    };

    Timer.start("Processing patterns");
    process_sequences(seq, o.numThreads, ms_step);
    Timer.stop(); //Processing patterns
    
    std::cout << "\tCPU query time: " << total_ms_time << " seconds" << std::endl;
    std::cout << "\t\tTime per base: " << (total_ms_time / total_seq_len) * 1e9 << " nanoseconds" << std::endl;
    std::cout << "\tCPU write time: " << total_write_time << " seconds" << std::endl << std::endl;
    #ifdef STATS
    msIndex.print_ms_stats();
    #endif

    fclose(out_len);
    fclose(out_pos);
    kseq_destroy(seq);
    fclose(fp);
    Timer.stop(); //msComputer
    return 0;
}