#include"util/util.h"
#include"matchingStatistics/msIndex.h"

void printUsage() {
    std::cout << 
        "MEM computes the (super or locally) maximal exact matches in the text with respect to itself.\n"
        "It requires as input the ms_index generated msIndexBuilder.\n"
        "\n"
        "Usage: MEM <arguments>\n"
        "Options:\n"
        "  Input:\n"
        "    -i          FILE                       REQUIRED       file name of input (ends with '" << ms_index_extension << "'), an index generated by msIndexBuilder.\n"
        "    -o          FILE                       REQUIRED       file name of output\n"
        "  MEM:\n"
        "    -MEM        [SM,LM]                    REQUIRED       type of MEM to output, super maximal exact matches or locally maximal exact matches.\n"
        "    -L          INT                        optional       minimum length of outputted MEMs (inclusive), must be nonnegative and > 0. REQUIRED for LM\n"
        "  General:\n"
        "    -p          INT                        optional       Limit the program to (nonnegative) INT threads. By default uses maximum available. Maximum on this hardware is " << omp_get_max_threads() << "\n"
        "    -v          [quiet,time,verb]          optional       Verbosity, verb for most verbose output, time for timer info, and quiet for no output. time is default.\n"
        "    -h, --help                             optional       Print this help message.\n"
        ;
}

struct options{
    std::string inputFile, oMEMs;
    bool SMEM = false, LEM = false;
    uint64_t L = 1;
    unsigned numThreads = omp_get_max_threads();
    verbosity v = TIME;
}o;

void processOptions(const int argc, const char* argv[]) {
    std::vector<bool> used(argc);
    used[0] = true;

    if (argc == 1 || getArgument(argc, argv, used, "-h", false, false) != "" || getArgument(argc, argv, used, "--help", false, false) != "") {
        printUsage();
        exit(0);
    }

    o.inputFile = getArgument(argc, argv, used, "-i", true, true);
    o.oMEMs = getArgument(argc, argv, used, "-o", true, true);
    std::string s = getArgument(argc, argv, used, "-v", false, true);
    if (s == "quiet")
        o.v = QUIET;
    else if (s == "time" || s == "")
        o.v = TIME;
    else if (s == "verb")
        o.v = VERB;
    else {
        std::cerr << "Invalid value passed to -v '" << s << "'\n";
        exit(1);
    }

    s = getArgument(argc, argv, used, "-MEM", true, true);
    if (s == "LM") 
        o.LEM = true;
    else if (s == "SM")
        o.SMEM = true;
    else {
        std::cerr << "Invalid value passed to -MEM '" << s << "', must be either 'SM' or 'LM'.\n";
        exit(1);
    }


    s = getArgument(argc, argv, used, "-p", false, true);
    if (s != "")
        o.numThreads = std::stoul(s);

    s = getArgument(argc, argv, used, "-L", o.LEM, true);
    if (s != "") {
        o.L = std::stoull(s);
        if (o.L == 0) {
            std::cerr << "Invalid value passe to -L, length threshold must be larger than 0!\n";
            exit(1);
        }
    }

    for (int i = 0; i < argc; ++i)
        if (!used[i]) {
            std::cout << "Argument " << i << ", '" << argv[i] << "' not recognized or used as an argument for another option. It might have been passed more than once (invalid).\n";
            exit(1);
        }
    testInFile(o.inputFile);
    testOutFile(o.oMEMs);
}

int main(const int argc, const char *argv[]) {
    processOptions(argc, argv);
    omp_set_num_threads(o.numThreads);
    if (o.v >= TIME) {
        std::string msg(argv[0]);
        for (int i = 1; i < argc; ++i)
            msg += std::string(" ") + argv[i];
        Timer.start(msg);
    }

    std::ifstream in = safeOpenFile<std::ifstream>(o.inputFile);
    std::ofstream out = safeOpenFile<std::ofstream>(o.oMEMs);

    if (o.v >= TIME) { Timer.start("Loading index"); }
    MSIndex ind;
    ind.load(in);
    if (o.v >= TIME) { Timer.stop(); }

    if (o.v >= TIME) { Timer.start("Computing MEMs"); }
    if (o.SMEM)
        ind.superMaximalRepeats(out, o.L);
    if (o.LEM)
        ind.repeats(out, o.L);
    if (o.v >= TIME) { Timer.stop(); } 

    if (o.v >= TIME) { Timer.stop(); } //MEM
    /*
    std::cout << "Outputting" << ((strcmp(argv[1], "LM"))? " supermaximal repeats" : " repeats")
        << " of length " << len << std::endl;

    


    
    Timer.start("Loading");
    OptBWTRL index(argv[argc-1]);
    Timer.stop(); //Loading

    if (strcmp(argv[1], "SM") == 0) {
        Timer.start("Computing Supermaximal Repeats");
        index.superMaximalRepeats(std::cout, len);
        Timer.stop();
    }

    if (strcmp(argv[1], "LM") == 0) {
        Timer.start("Computing repeats");
        index.repeats(std::cout, len);
        Timer.stop();
    }
     */
    return 0;
}
